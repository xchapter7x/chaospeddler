// This file was generated by counterfeiter
package fakes

import (
	"database/sql"
	"sync"

	"github.com/jinzhu/gorm"
	"github.com/xchapter7x/chaospeddler/service_broker"
)

type FakeGormDB struct {
	AddErrorStub        func(err error) error
	addErrorMutex       sync.RWMutex
	addErrorArgsForCall []struct {
		err error
	}
	addErrorReturns struct {
		result1 error
	}
	AddForeignKeyStub        func(field string, dest string, onDelete string, onUpdate string) *gorm.DB
	addForeignKeyMutex       sync.RWMutex
	addForeignKeyArgsForCall []struct {
		field    string
		dest     string
		onDelete string
		onUpdate string
	}
	addForeignKeyReturns struct {
		result1 *gorm.DB
	}
	AddIndexStub        func(indexName string, column ...string) *gorm.DB
	addIndexMutex       sync.RWMutex
	addIndexArgsForCall []struct {
		indexName string
		column    []string
	}
	addIndexReturns struct {
		result1 *gorm.DB
	}
	AddUniqueIndexStub        func(indexName string, column ...string) *gorm.DB
	addUniqueIndexMutex       sync.RWMutex
	addUniqueIndexArgsForCall []struct {
		indexName string
		column    []string
	}
	addUniqueIndexReturns struct {
		result1 *gorm.DB
	}
	AssignStub        func(attrs ...interface{}) *gorm.DB
	assignMutex       sync.RWMutex
	assignArgsForCall []struct {
		attrs []interface{}
	}
	assignReturns struct {
		result1 *gorm.DB
	}
	AssociationStub        func(column string) *gorm.Association
	associationMutex       sync.RWMutex
	associationArgsForCall []struct {
		column string
	}
	associationReturns struct {
		result1 *gorm.Association
	}
	AttrsStub        func(attrs ...interface{}) *gorm.DB
	attrsMutex       sync.RWMutex
	attrsArgsForCall []struct {
		attrs []interface{}
	}
	attrsReturns struct {
		result1 *gorm.DB
	}
	AutoMigrateStub        func(values ...interface{}) *gorm.DB
	autoMigrateMutex       sync.RWMutex
	autoMigrateArgsForCall []struct {
		values []interface{}
	}
	autoMigrateReturns struct {
		result1 *gorm.DB
	}
	BeginStub        func() *gorm.DB
	beginMutex       sync.RWMutex
	beginArgsForCall []struct{}
	beginReturns     struct {
		result1 *gorm.DB
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	CommitStub        func() *gorm.DB
	commitMutex       sync.RWMutex
	commitArgsForCall []struct{}
	commitReturns     struct {
		result1 *gorm.DB
	}
	CountStub        func(value interface{}) *gorm.DB
	countMutex       sync.RWMutex
	countArgsForCall []struct {
		value interface{}
	}
	countReturns struct {
		result1 *gorm.DB
	}
	CreateStub        func(value interface{}) *gorm.DB
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		value interface{}
	}
	createReturns struct {
		result1 *gorm.DB
	}
	CreateTableStub        func(values ...interface{}) *gorm.DB
	createTableMutex       sync.RWMutex
	createTableArgsForCall []struct {
		values []interface{}
	}
	createTableReturns struct {
		result1 *gorm.DB
	}
	CurrentDatabaseStub        func() string
	currentDatabaseMutex       sync.RWMutex
	currentDatabaseArgsForCall []struct{}
	currentDatabaseReturns     struct {
		result1 string
	}
	DBStub        func() *sql.DB
	dBMutex       sync.RWMutex
	dBArgsForCall []struct{}
	dBReturns     struct {
		result1 *sql.DB
	}
	DebugStub        func() *gorm.DB
	debugMutex       sync.RWMutex
	debugArgsForCall []struct{}
	debugReturns     struct {
		result1 *gorm.DB
	}
	DeleteStub        func(value interface{}, where ...interface{}) *gorm.DB
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		value interface{}
		where []interface{}
	}
	deleteReturns struct {
		result1 *gorm.DB
	}
	DropColumnStub        func(column string) *gorm.DB
	dropColumnMutex       sync.RWMutex
	dropColumnArgsForCall []struct {
		column string
	}
	dropColumnReturns struct {
		result1 *gorm.DB
	}
	DropTableStub        func(values ...interface{}) *gorm.DB
	dropTableMutex       sync.RWMutex
	dropTableArgsForCall []struct {
		values []interface{}
	}
	dropTableReturns struct {
		result1 *gorm.DB
	}
	DropTableIfExistsStub        func(values ...interface{}) *gorm.DB
	dropTableIfExistsMutex       sync.RWMutex
	dropTableIfExistsArgsForCall []struct {
		values []interface{}
	}
	dropTableIfExistsReturns struct {
		result1 *gorm.DB
	}
	ExecStub        func(sql string, values ...interface{}) *gorm.DB
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		sql    string
		values []interface{}
	}
	execReturns struct {
		result1 *gorm.DB
	}
	FindStub        func(out interface{}, where ...interface{}) *gorm.DB
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		out   interface{}
		where []interface{}
	}
	findReturns struct {
		result1 *gorm.DB
	}
	FirstStub        func(out interface{}, where ...interface{}) *gorm.DB
	firstMutex       sync.RWMutex
	firstArgsForCall []struct {
		out   interface{}
		where []interface{}
	}
	firstReturns struct {
		result1 *gorm.DB
	}
	FirstOrCreateStub        func(out interface{}, where ...interface{}) *gorm.DB
	firstOrCreateMutex       sync.RWMutex
	firstOrCreateArgsForCall []struct {
		out   interface{}
		where []interface{}
	}
	firstOrCreateReturns struct {
		result1 *gorm.DB
	}
	FirstOrInitStub        func(out interface{}, where ...interface{}) *gorm.DB
	firstOrInitMutex       sync.RWMutex
	firstOrInitArgsForCall []struct {
		out   interface{}
		where []interface{}
	}
	firstOrInitReturns struct {
		result1 *gorm.DB
	}
	GetStub        func(name string) (value interface{}, ok bool)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		name string
	}
	getReturns struct {
		result1 interface{}
		result2 bool
	}
	GetErrorsStub        func() (errors []error)
	getErrorsMutex       sync.RWMutex
	getErrorsArgsForCall []struct{}
	getErrorsReturns     struct {
		result1 []error
	}
	GroupStub        func(query string) *gorm.DB
	groupMutex       sync.RWMutex
	groupArgsForCall []struct {
		query string
	}
	groupReturns struct {
		result1 *gorm.DB
	}
	HasTableStub        func(value interface{}) bool
	hasTableMutex       sync.RWMutex
	hasTableArgsForCall []struct {
		value interface{}
	}
	hasTableReturns struct {
		result1 bool
	}
	HavingStub        func(query string, values ...interface{}) *gorm.DB
	havingMutex       sync.RWMutex
	havingArgsForCall []struct {
		query  string
		values []interface{}
	}
	havingReturns struct {
		result1 *gorm.DB
	}
	InstantSetStub        func(name string, value interface{}) *gorm.DB
	instantSetMutex       sync.RWMutex
	instantSetArgsForCall []struct {
		name  string
		value interface{}
	}
	instantSetReturns struct {
		result1 *gorm.DB
	}
	JoinsStub        func(query string) *gorm.DB
	joinsMutex       sync.RWMutex
	joinsArgsForCall []struct {
		query string
	}
	joinsReturns struct {
		result1 *gorm.DB
	}
	LastStub        func(out interface{}, where ...interface{}) *gorm.DB
	lastMutex       sync.RWMutex
	lastArgsForCall []struct {
		out   interface{}
		where []interface{}
	}
	lastReturns struct {
		result1 *gorm.DB
	}
	LimitStub        func(value interface{}) *gorm.DB
	limitMutex       sync.RWMutex
	limitArgsForCall []struct {
		value interface{}
	}
	limitReturns struct {
		result1 *gorm.DB
	}
	LogModeStub        func(enable bool) *gorm.DB
	logModeMutex       sync.RWMutex
	logModeArgsForCall []struct {
		enable bool
	}
	logModeReturns struct {
		result1 *gorm.DB
	}
	ModelStub        func(value interface{}) *gorm.DB
	modelMutex       sync.RWMutex
	modelArgsForCall []struct {
		value interface{}
	}
	modelReturns struct {
		result1 *gorm.DB
	}
	ModifyColumnStub        func(column string, typ string) *gorm.DB
	modifyColumnMutex       sync.RWMutex
	modifyColumnArgsForCall []struct {
		column string
		typ    string
	}
	modifyColumnReturns struct {
		result1 *gorm.DB
	}
	NewStub        func() *gorm.DB
	newMutex       sync.RWMutex
	newArgsForCall []struct{}
	newReturns     struct {
		result1 *gorm.DB
	}
	NewRecordStub        func(value interface{}) bool
	newRecordMutex       sync.RWMutex
	newRecordArgsForCall []struct {
		value interface{}
	}
	newRecordReturns struct {
		result1 bool
	}
	NewScopeStub        func(value interface{}) *gorm.Scope
	newScopeMutex       sync.RWMutex
	newScopeArgsForCall []struct {
		value interface{}
	}
	newScopeReturns struct {
		result1 *gorm.Scope
	}
	NotStub        func(query interface{}, args ...interface{}) *gorm.DB
	notMutex       sync.RWMutex
	notArgsForCall []struct {
		query interface{}
		args  []interface{}
	}
	notReturns struct {
		result1 *gorm.DB
	}
	OffsetStub        func(value interface{}) *gorm.DB
	offsetMutex       sync.RWMutex
	offsetArgsForCall []struct {
		value interface{}
	}
	offsetReturns struct {
		result1 *gorm.DB
	}
	OmitStub        func(columns ...string) *gorm.DB
	omitMutex       sync.RWMutex
	omitArgsForCall []struct {
		columns []string
	}
	omitReturns struct {
		result1 *gorm.DB
	}
	OrStub        func(query interface{}, args ...interface{}) *gorm.DB
	orMutex       sync.RWMutex
	orArgsForCall []struct {
		query interface{}
		args  []interface{}
	}
	orReturns struct {
		result1 *gorm.DB
	}
	OrderStub        func(value string, reorder ...bool) *gorm.DB
	orderMutex       sync.RWMutex
	orderArgsForCall []struct {
		value   string
		reorder []bool
	}
	orderReturns struct {
		result1 *gorm.DB
	}
	PluckStub        func(column string, value interface{}) *gorm.DB
	pluckMutex       sync.RWMutex
	pluckArgsForCall []struct {
		column string
		value  interface{}
	}
	pluckReturns struct {
		result1 *gorm.DB
	}
	PreloadStub        func(column string, conditions ...interface{}) *gorm.DB
	preloadMutex       sync.RWMutex
	preloadArgsForCall []struct {
		column     string
		conditions []interface{}
	}
	preloadReturns struct {
		result1 *gorm.DB
	}
	RawStub        func(sql string, values ...interface{}) *gorm.DB
	rawMutex       sync.RWMutex
	rawArgsForCall []struct {
		sql    string
		values []interface{}
	}
	rawReturns struct {
		result1 *gorm.DB
	}
	RecordNotFoundStub        func() bool
	recordNotFoundMutex       sync.RWMutex
	recordNotFoundArgsForCall []struct{}
	recordNotFoundReturns     struct {
		result1 bool
	}
	RelatedStub        func(value interface{}, foreignKeys ...string) *gorm.DB
	relatedMutex       sync.RWMutex
	relatedArgsForCall []struct {
		value       interface{}
		foreignKeys []string
	}
	relatedReturns struct {
		result1 *gorm.DB
	}
	RemoveIndexStub        func(indexName string) *gorm.DB
	removeIndexMutex       sync.RWMutex
	removeIndexArgsForCall []struct {
		indexName string
	}
	removeIndexReturns struct {
		result1 *gorm.DB
	}
	RollbackStub        func() *gorm.DB
	rollbackMutex       sync.RWMutex
	rollbackArgsForCall []struct{}
	rollbackReturns     struct {
		result1 *gorm.DB
	}
	RowStub        func() *sql.Row
	rowMutex       sync.RWMutex
	rowArgsForCall []struct{}
	rowReturns     struct {
		result1 *sql.Row
	}
	RowsStub        func() (*sql.Rows, error)
	rowsMutex       sync.RWMutex
	rowsArgsForCall []struct{}
	rowsReturns     struct {
		result1 *sql.Rows
		result2 error
	}
	SaveStub        func(value interface{}) *gorm.DB
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
		value interface{}
	}
	saveReturns struct {
		result1 *gorm.DB
	}
	ScanStub        func(dest interface{}) *gorm.DB
	scanMutex       sync.RWMutex
	scanArgsForCall []struct {
		dest interface{}
	}
	scanReturns struct {
		result1 *gorm.DB
	}
	ScopesStub        func(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB
	scopesMutex       sync.RWMutex
	scopesArgsForCall []struct {
		funcs []func(*gorm.DB) *gorm.DB
	}
	scopesReturns struct {
		result1 *gorm.DB
	}
	SelectStub        func(query interface{}, args ...interface{}) *gorm.DB
	selectMutex       sync.RWMutex
	selectArgsForCall []struct {
		query interface{}
		args  []interface{}
	}
	selectReturns struct {
		result1 *gorm.DB
	}
	SetStub        func(name string, value interface{}) *gorm.DB
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		name  string
		value interface{}
	}
	setReturns struct {
		result1 *gorm.DB
	}
	SetJoinTableHandlerStub        func(source interface{}, column string, handler gorm.JoinTableHandlerInterface)
	setJoinTableHandlerMutex       sync.RWMutex
	setJoinTableHandlerArgsForCall []struct {
		source  interface{}
		column  string
		handler gorm.JoinTableHandlerInterface
	}
	SingularTableStub        func(enable bool)
	singularTableMutex       sync.RWMutex
	singularTableArgsForCall []struct {
		enable bool
	}
	TableStub        func(name string) *gorm.DB
	tableMutex       sync.RWMutex
	tableArgsForCall []struct {
		name string
	}
	tableReturns struct {
		result1 *gorm.DB
	}
	UnscopedStub        func() *gorm.DB
	unscopedMutex       sync.RWMutex
	unscopedArgsForCall []struct{}
	unscopedReturns     struct {
		result1 *gorm.DB
	}
	UpdateStub        func(attrs ...interface{}) *gorm.DB
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		attrs []interface{}
	}
	updateReturns struct {
		result1 *gorm.DB
	}
	UpdateColumnStub        func(attrs ...interface{}) *gorm.DB
	updateColumnMutex       sync.RWMutex
	updateColumnArgsForCall []struct {
		attrs []interface{}
	}
	updateColumnReturns struct {
		result1 *gorm.DB
	}
	UpdateColumnsStub        func(values interface{}) *gorm.DB
	updateColumnsMutex       sync.RWMutex
	updateColumnsArgsForCall []struct {
		values interface{}
	}
	updateColumnsReturns struct {
		result1 *gorm.DB
	}
	UpdatesStub        func(values interface{}, ignoreProtectedAttrs ...bool) *gorm.DB
	updatesMutex       sync.RWMutex
	updatesArgsForCall []struct {
		values               interface{}
		ignoreProtectedAttrs []bool
	}
	updatesReturns struct {
		result1 *gorm.DB
	}
	WhereStub        func(query interface{}, args ...interface{}) chaospeddler.GormDB
	whereMutex       sync.RWMutex
	whereArgsForCall []struct {
		query interface{}
		args  []interface{}
	}
	whereReturns struct {
		result1 chaospeddler.GormDB
	}
}

func (fake *FakeGormDB) AddError(err error) error {
	fake.addErrorMutex.Lock()
	fake.addErrorArgsForCall = append(fake.addErrorArgsForCall, struct {
		err error
	}{err})
	fake.addErrorMutex.Unlock()
	if fake.AddErrorStub != nil {
		return fake.AddErrorStub(err)
	} else {
		return fake.addErrorReturns.result1
	}
}

func (fake *FakeGormDB) AddErrorCallCount() int {
	fake.addErrorMutex.RLock()
	defer fake.addErrorMutex.RUnlock()
	return len(fake.addErrorArgsForCall)
}

func (fake *FakeGormDB) AddErrorArgsForCall(i int) error {
	fake.addErrorMutex.RLock()
	defer fake.addErrorMutex.RUnlock()
	return fake.addErrorArgsForCall[i].err
}

func (fake *FakeGormDB) AddErrorReturns(result1 error) {
	fake.AddErrorStub = nil
	fake.addErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGormDB) AddForeignKey(field string, dest string, onDelete string, onUpdate string) *gorm.DB {
	fake.addForeignKeyMutex.Lock()
	fake.addForeignKeyArgsForCall = append(fake.addForeignKeyArgsForCall, struct {
		field    string
		dest     string
		onDelete string
		onUpdate string
	}{field, dest, onDelete, onUpdate})
	fake.addForeignKeyMutex.Unlock()
	if fake.AddForeignKeyStub != nil {
		return fake.AddForeignKeyStub(field, dest, onDelete, onUpdate)
	} else {
		return fake.addForeignKeyReturns.result1
	}
}

func (fake *FakeGormDB) AddForeignKeyCallCount() int {
	fake.addForeignKeyMutex.RLock()
	defer fake.addForeignKeyMutex.RUnlock()
	return len(fake.addForeignKeyArgsForCall)
}

func (fake *FakeGormDB) AddForeignKeyArgsForCall(i int) (string, string, string, string) {
	fake.addForeignKeyMutex.RLock()
	defer fake.addForeignKeyMutex.RUnlock()
	return fake.addForeignKeyArgsForCall[i].field, fake.addForeignKeyArgsForCall[i].dest, fake.addForeignKeyArgsForCall[i].onDelete, fake.addForeignKeyArgsForCall[i].onUpdate
}

func (fake *FakeGormDB) AddForeignKeyReturns(result1 *gorm.DB) {
	fake.AddForeignKeyStub = nil
	fake.addForeignKeyReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) AddIndex(indexName string, column ...string) *gorm.DB {
	fake.addIndexMutex.Lock()
	fake.addIndexArgsForCall = append(fake.addIndexArgsForCall, struct {
		indexName string
		column    []string
	}{indexName, column})
	fake.addIndexMutex.Unlock()
	if fake.AddIndexStub != nil {
		return fake.AddIndexStub(indexName, column...)
	} else {
		return fake.addIndexReturns.result1
	}
}

func (fake *FakeGormDB) AddIndexCallCount() int {
	fake.addIndexMutex.RLock()
	defer fake.addIndexMutex.RUnlock()
	return len(fake.addIndexArgsForCall)
}

func (fake *FakeGormDB) AddIndexArgsForCall(i int) (string, []string) {
	fake.addIndexMutex.RLock()
	defer fake.addIndexMutex.RUnlock()
	return fake.addIndexArgsForCall[i].indexName, fake.addIndexArgsForCall[i].column
}

func (fake *FakeGormDB) AddIndexReturns(result1 *gorm.DB) {
	fake.AddIndexStub = nil
	fake.addIndexReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) AddUniqueIndex(indexName string, column ...string) *gorm.DB {
	fake.addUniqueIndexMutex.Lock()
	fake.addUniqueIndexArgsForCall = append(fake.addUniqueIndexArgsForCall, struct {
		indexName string
		column    []string
	}{indexName, column})
	fake.addUniqueIndexMutex.Unlock()
	if fake.AddUniqueIndexStub != nil {
		return fake.AddUniqueIndexStub(indexName, column...)
	} else {
		return fake.addUniqueIndexReturns.result1
	}
}

func (fake *FakeGormDB) AddUniqueIndexCallCount() int {
	fake.addUniqueIndexMutex.RLock()
	defer fake.addUniqueIndexMutex.RUnlock()
	return len(fake.addUniqueIndexArgsForCall)
}

func (fake *FakeGormDB) AddUniqueIndexArgsForCall(i int) (string, []string) {
	fake.addUniqueIndexMutex.RLock()
	defer fake.addUniqueIndexMutex.RUnlock()
	return fake.addUniqueIndexArgsForCall[i].indexName, fake.addUniqueIndexArgsForCall[i].column
}

func (fake *FakeGormDB) AddUniqueIndexReturns(result1 *gorm.DB) {
	fake.AddUniqueIndexStub = nil
	fake.addUniqueIndexReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Assign(attrs ...interface{}) *gorm.DB {
	fake.assignMutex.Lock()
	fake.assignArgsForCall = append(fake.assignArgsForCall, struct {
		attrs []interface{}
	}{attrs})
	fake.assignMutex.Unlock()
	if fake.AssignStub != nil {
		return fake.AssignStub(attrs...)
	} else {
		return fake.assignReturns.result1
	}
}

func (fake *FakeGormDB) AssignCallCount() int {
	fake.assignMutex.RLock()
	defer fake.assignMutex.RUnlock()
	return len(fake.assignArgsForCall)
}

func (fake *FakeGormDB) AssignArgsForCall(i int) []interface{} {
	fake.assignMutex.RLock()
	defer fake.assignMutex.RUnlock()
	return fake.assignArgsForCall[i].attrs
}

func (fake *FakeGormDB) AssignReturns(result1 *gorm.DB) {
	fake.AssignStub = nil
	fake.assignReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Association(column string) *gorm.Association {
	fake.associationMutex.Lock()
	fake.associationArgsForCall = append(fake.associationArgsForCall, struct {
		column string
	}{column})
	fake.associationMutex.Unlock()
	if fake.AssociationStub != nil {
		return fake.AssociationStub(column)
	} else {
		return fake.associationReturns.result1
	}
}

func (fake *FakeGormDB) AssociationCallCount() int {
	fake.associationMutex.RLock()
	defer fake.associationMutex.RUnlock()
	return len(fake.associationArgsForCall)
}

func (fake *FakeGormDB) AssociationArgsForCall(i int) string {
	fake.associationMutex.RLock()
	defer fake.associationMutex.RUnlock()
	return fake.associationArgsForCall[i].column
}

func (fake *FakeGormDB) AssociationReturns(result1 *gorm.Association) {
	fake.AssociationStub = nil
	fake.associationReturns = struct {
		result1 *gorm.Association
	}{result1}
}

func (fake *FakeGormDB) Attrs(attrs ...interface{}) *gorm.DB {
	fake.attrsMutex.Lock()
	fake.attrsArgsForCall = append(fake.attrsArgsForCall, struct {
		attrs []interface{}
	}{attrs})
	fake.attrsMutex.Unlock()
	if fake.AttrsStub != nil {
		return fake.AttrsStub(attrs...)
	} else {
		return fake.attrsReturns.result1
	}
}

func (fake *FakeGormDB) AttrsCallCount() int {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return len(fake.attrsArgsForCall)
}

func (fake *FakeGormDB) AttrsArgsForCall(i int) []interface{} {
	fake.attrsMutex.RLock()
	defer fake.attrsMutex.RUnlock()
	return fake.attrsArgsForCall[i].attrs
}

func (fake *FakeGormDB) AttrsReturns(result1 *gorm.DB) {
	fake.AttrsStub = nil
	fake.attrsReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) AutoMigrate(values ...interface{}) *gorm.DB {
	fake.autoMigrateMutex.Lock()
	fake.autoMigrateArgsForCall = append(fake.autoMigrateArgsForCall, struct {
		values []interface{}
	}{values})
	fake.autoMigrateMutex.Unlock()
	if fake.AutoMigrateStub != nil {
		return fake.AutoMigrateStub(values...)
	} else {
		return fake.autoMigrateReturns.result1
	}
}

func (fake *FakeGormDB) AutoMigrateCallCount() int {
	fake.autoMigrateMutex.RLock()
	defer fake.autoMigrateMutex.RUnlock()
	return len(fake.autoMigrateArgsForCall)
}

func (fake *FakeGormDB) AutoMigrateArgsForCall(i int) []interface{} {
	fake.autoMigrateMutex.RLock()
	defer fake.autoMigrateMutex.RUnlock()
	return fake.autoMigrateArgsForCall[i].values
}

func (fake *FakeGormDB) AutoMigrateReturns(result1 *gorm.DB) {
	fake.AutoMigrateStub = nil
	fake.autoMigrateReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Begin() *gorm.DB {
	fake.beginMutex.Lock()
	fake.beginArgsForCall = append(fake.beginArgsForCall, struct{}{})
	fake.beginMutex.Unlock()
	if fake.BeginStub != nil {
		return fake.BeginStub()
	} else {
		return fake.beginReturns.result1
	}
}

func (fake *FakeGormDB) BeginCallCount() int {
	fake.beginMutex.RLock()
	defer fake.beginMutex.RUnlock()
	return len(fake.beginArgsForCall)
}

func (fake *FakeGormDB) BeginReturns(result1 *gorm.DB) {
	fake.BeginStub = nil
	fake.beginReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Close() error {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	} else {
		return fake.closeReturns.result1
	}
}

func (fake *FakeGormDB) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeGormDB) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGormDB) Commit() *gorm.DB {
	fake.commitMutex.Lock()
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct{}{})
	fake.commitMutex.Unlock()
	if fake.CommitStub != nil {
		return fake.CommitStub()
	} else {
		return fake.commitReturns.result1
	}
}

func (fake *FakeGormDB) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeGormDB) CommitReturns(result1 *gorm.DB) {
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Count(value interface{}) *gorm.DB {
	fake.countMutex.Lock()
	fake.countArgsForCall = append(fake.countArgsForCall, struct {
		value interface{}
	}{value})
	fake.countMutex.Unlock()
	if fake.CountStub != nil {
		return fake.CountStub(value)
	} else {
		return fake.countReturns.result1
	}
}

func (fake *FakeGormDB) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeGormDB) CountArgsForCall(i int) interface{} {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return fake.countArgsForCall[i].value
}

func (fake *FakeGormDB) CountReturns(result1 *gorm.DB) {
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Create(value interface{}) *gorm.DB {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		value interface{}
	}{value})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(value)
	} else {
		return fake.createReturns.result1
	}
}

func (fake *FakeGormDB) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeGormDB) CreateArgsForCall(i int) interface{} {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].value
}

func (fake *FakeGormDB) CreateReturns(result1 *gorm.DB) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) CreateTable(values ...interface{}) *gorm.DB {
	fake.createTableMutex.Lock()
	fake.createTableArgsForCall = append(fake.createTableArgsForCall, struct {
		values []interface{}
	}{values})
	fake.createTableMutex.Unlock()
	if fake.CreateTableStub != nil {
		return fake.CreateTableStub(values...)
	} else {
		return fake.createTableReturns.result1
	}
}

func (fake *FakeGormDB) CreateTableCallCount() int {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	return len(fake.createTableArgsForCall)
}

func (fake *FakeGormDB) CreateTableArgsForCall(i int) []interface{} {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	return fake.createTableArgsForCall[i].values
}

func (fake *FakeGormDB) CreateTableReturns(result1 *gorm.DB) {
	fake.CreateTableStub = nil
	fake.createTableReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) CurrentDatabase() string {
	fake.currentDatabaseMutex.Lock()
	fake.currentDatabaseArgsForCall = append(fake.currentDatabaseArgsForCall, struct{}{})
	fake.currentDatabaseMutex.Unlock()
	if fake.CurrentDatabaseStub != nil {
		return fake.CurrentDatabaseStub()
	} else {
		return fake.currentDatabaseReturns.result1
	}
}

func (fake *FakeGormDB) CurrentDatabaseCallCount() int {
	fake.currentDatabaseMutex.RLock()
	defer fake.currentDatabaseMutex.RUnlock()
	return len(fake.currentDatabaseArgsForCall)
}

func (fake *FakeGormDB) CurrentDatabaseReturns(result1 string) {
	fake.CurrentDatabaseStub = nil
	fake.currentDatabaseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGormDB) DB() *sql.DB {
	fake.dBMutex.Lock()
	fake.dBArgsForCall = append(fake.dBArgsForCall, struct{}{})
	fake.dBMutex.Unlock()
	if fake.DBStub != nil {
		return fake.DBStub()
	} else {
		return fake.dBReturns.result1
	}
}

func (fake *FakeGormDB) DBCallCount() int {
	fake.dBMutex.RLock()
	defer fake.dBMutex.RUnlock()
	return len(fake.dBArgsForCall)
}

func (fake *FakeGormDB) DBReturns(result1 *sql.DB) {
	fake.DBStub = nil
	fake.dBReturns = struct {
		result1 *sql.DB
	}{result1}
}

func (fake *FakeGormDB) Debug() *gorm.DB {
	fake.debugMutex.Lock()
	fake.debugArgsForCall = append(fake.debugArgsForCall, struct{}{})
	fake.debugMutex.Unlock()
	if fake.DebugStub != nil {
		return fake.DebugStub()
	} else {
		return fake.debugReturns.result1
	}
}

func (fake *FakeGormDB) DebugCallCount() int {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return len(fake.debugArgsForCall)
}

func (fake *FakeGormDB) DebugReturns(result1 *gorm.DB) {
	fake.DebugStub = nil
	fake.debugReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Delete(value interface{}, where ...interface{}) *gorm.DB {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		value interface{}
		where []interface{}
	}{value, where})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(value, where...)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeGormDB) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeGormDB) DeleteArgsForCall(i int) (interface{}, []interface{}) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].value, fake.deleteArgsForCall[i].where
}

func (fake *FakeGormDB) DeleteReturns(result1 *gorm.DB) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) DropColumn(column string) *gorm.DB {
	fake.dropColumnMutex.Lock()
	fake.dropColumnArgsForCall = append(fake.dropColumnArgsForCall, struct {
		column string
	}{column})
	fake.dropColumnMutex.Unlock()
	if fake.DropColumnStub != nil {
		return fake.DropColumnStub(column)
	} else {
		return fake.dropColumnReturns.result1
	}
}

func (fake *FakeGormDB) DropColumnCallCount() int {
	fake.dropColumnMutex.RLock()
	defer fake.dropColumnMutex.RUnlock()
	return len(fake.dropColumnArgsForCall)
}

func (fake *FakeGormDB) DropColumnArgsForCall(i int) string {
	fake.dropColumnMutex.RLock()
	defer fake.dropColumnMutex.RUnlock()
	return fake.dropColumnArgsForCall[i].column
}

func (fake *FakeGormDB) DropColumnReturns(result1 *gorm.DB) {
	fake.DropColumnStub = nil
	fake.dropColumnReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) DropTable(values ...interface{}) *gorm.DB {
	fake.dropTableMutex.Lock()
	fake.dropTableArgsForCall = append(fake.dropTableArgsForCall, struct {
		values []interface{}
	}{values})
	fake.dropTableMutex.Unlock()
	if fake.DropTableStub != nil {
		return fake.DropTableStub(values...)
	} else {
		return fake.dropTableReturns.result1
	}
}

func (fake *FakeGormDB) DropTableCallCount() int {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	return len(fake.dropTableArgsForCall)
}

func (fake *FakeGormDB) DropTableArgsForCall(i int) []interface{} {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	return fake.dropTableArgsForCall[i].values
}

func (fake *FakeGormDB) DropTableReturns(result1 *gorm.DB) {
	fake.DropTableStub = nil
	fake.dropTableReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) DropTableIfExists(values ...interface{}) *gorm.DB {
	fake.dropTableIfExistsMutex.Lock()
	fake.dropTableIfExistsArgsForCall = append(fake.dropTableIfExistsArgsForCall, struct {
		values []interface{}
	}{values})
	fake.dropTableIfExistsMutex.Unlock()
	if fake.DropTableIfExistsStub != nil {
		return fake.DropTableIfExistsStub(values...)
	} else {
		return fake.dropTableIfExistsReturns.result1
	}
}

func (fake *FakeGormDB) DropTableIfExistsCallCount() int {
	fake.dropTableIfExistsMutex.RLock()
	defer fake.dropTableIfExistsMutex.RUnlock()
	return len(fake.dropTableIfExistsArgsForCall)
}

func (fake *FakeGormDB) DropTableIfExistsArgsForCall(i int) []interface{} {
	fake.dropTableIfExistsMutex.RLock()
	defer fake.dropTableIfExistsMutex.RUnlock()
	return fake.dropTableIfExistsArgsForCall[i].values
}

func (fake *FakeGormDB) DropTableIfExistsReturns(result1 *gorm.DB) {
	fake.DropTableIfExistsStub = nil
	fake.dropTableIfExistsReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Exec(sql string, values ...interface{}) *gorm.DB {
	fake.execMutex.Lock()
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		sql    string
		values []interface{}
	}{sql, values})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(sql, values...)
	} else {
		return fake.execReturns.result1
	}
}

func (fake *FakeGormDB) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeGormDB) ExecArgsForCall(i int) (string, []interface{}) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return fake.execArgsForCall[i].sql, fake.execArgsForCall[i].values
}

func (fake *FakeGormDB) ExecReturns(result1 *gorm.DB) {
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Find(out interface{}, where ...interface{}) *gorm.DB {
	fake.findMutex.Lock()
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		out   interface{}
		where []interface{}
	}{out, where})
	fake.findMutex.Unlock()
	if fake.FindStub != nil {
		return fake.FindStub(out, where...)
	} else {
		return fake.findReturns.result1
	}
}

func (fake *FakeGormDB) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeGormDB) FindArgsForCall(i int) (interface{}, []interface{}) {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return fake.findArgsForCall[i].out, fake.findArgsForCall[i].where
}

func (fake *FakeGormDB) FindReturns(result1 *gorm.DB) {
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) First(out interface{}, where ...interface{}) *gorm.DB {
	fake.firstMutex.Lock()
	fake.firstArgsForCall = append(fake.firstArgsForCall, struct {
		out   interface{}
		where []interface{}
	}{out, where})
	fake.firstMutex.Unlock()
	if fake.FirstStub != nil {
		return fake.FirstStub(out, where...)
	} else {
		return fake.firstReturns.result1
	}
}

func (fake *FakeGormDB) FirstCallCount() int {
	fake.firstMutex.RLock()
	defer fake.firstMutex.RUnlock()
	return len(fake.firstArgsForCall)
}

func (fake *FakeGormDB) FirstArgsForCall(i int) (interface{}, []interface{}) {
	fake.firstMutex.RLock()
	defer fake.firstMutex.RUnlock()
	return fake.firstArgsForCall[i].out, fake.firstArgsForCall[i].where
}

func (fake *FakeGormDB) FirstReturns(result1 *gorm.DB) {
	fake.FirstStub = nil
	fake.firstReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) FirstOrCreate(out interface{}, where ...interface{}) *gorm.DB {
	fake.firstOrCreateMutex.Lock()
	fake.firstOrCreateArgsForCall = append(fake.firstOrCreateArgsForCall, struct {
		out   interface{}
		where []interface{}
	}{out, where})
	fake.firstOrCreateMutex.Unlock()
	if fake.FirstOrCreateStub != nil {
		return fake.FirstOrCreateStub(out, where...)
	} else {
		return fake.firstOrCreateReturns.result1
	}
}

func (fake *FakeGormDB) FirstOrCreateCallCount() int {
	fake.firstOrCreateMutex.RLock()
	defer fake.firstOrCreateMutex.RUnlock()
	return len(fake.firstOrCreateArgsForCall)
}

func (fake *FakeGormDB) FirstOrCreateArgsForCall(i int) (interface{}, []interface{}) {
	fake.firstOrCreateMutex.RLock()
	defer fake.firstOrCreateMutex.RUnlock()
	return fake.firstOrCreateArgsForCall[i].out, fake.firstOrCreateArgsForCall[i].where
}

func (fake *FakeGormDB) FirstOrCreateReturns(result1 *gorm.DB) {
	fake.FirstOrCreateStub = nil
	fake.firstOrCreateReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) FirstOrInit(out interface{}, where ...interface{}) *gorm.DB {
	fake.firstOrInitMutex.Lock()
	fake.firstOrInitArgsForCall = append(fake.firstOrInitArgsForCall, struct {
		out   interface{}
		where []interface{}
	}{out, where})
	fake.firstOrInitMutex.Unlock()
	if fake.FirstOrInitStub != nil {
		return fake.FirstOrInitStub(out, where...)
	} else {
		return fake.firstOrInitReturns.result1
	}
}

func (fake *FakeGormDB) FirstOrInitCallCount() int {
	fake.firstOrInitMutex.RLock()
	defer fake.firstOrInitMutex.RUnlock()
	return len(fake.firstOrInitArgsForCall)
}

func (fake *FakeGormDB) FirstOrInitArgsForCall(i int) (interface{}, []interface{}) {
	fake.firstOrInitMutex.RLock()
	defer fake.firstOrInitMutex.RUnlock()
	return fake.firstOrInitArgsForCall[i].out, fake.firstOrInitArgsForCall[i].where
}

func (fake *FakeGormDB) FirstOrInitReturns(result1 *gorm.DB) {
	fake.FirstOrInitStub = nil
	fake.firstOrInitReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Get(name string) (value interface{}, ok bool) {
	fake.getMutex.Lock()
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		name string
	}{name})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(name)
	} else {
		return fake.getReturns.result1, fake.getReturns.result2
	}
}

func (fake *FakeGormDB) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeGormDB) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].name
}

func (fake *FakeGormDB) GetReturns(result1 interface{}, result2 bool) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 interface{}
		result2 bool
	}{result1, result2}
}

func (fake *FakeGormDB) GetErrors() (errors []error) {
	fake.getErrorsMutex.Lock()
	fake.getErrorsArgsForCall = append(fake.getErrorsArgsForCall, struct{}{})
	fake.getErrorsMutex.Unlock()
	if fake.GetErrorsStub != nil {
		return fake.GetErrorsStub()
	} else {
		return fake.getErrorsReturns.result1
	}
}

func (fake *FakeGormDB) GetErrorsCallCount() int {
	fake.getErrorsMutex.RLock()
	defer fake.getErrorsMutex.RUnlock()
	return len(fake.getErrorsArgsForCall)
}

func (fake *FakeGormDB) GetErrorsReturns(result1 []error) {
	fake.GetErrorsStub = nil
	fake.getErrorsReturns = struct {
		result1 []error
	}{result1}
}

func (fake *FakeGormDB) Group(query string) *gorm.DB {
	fake.groupMutex.Lock()
	fake.groupArgsForCall = append(fake.groupArgsForCall, struct {
		query string
	}{query})
	fake.groupMutex.Unlock()
	if fake.GroupStub != nil {
		return fake.GroupStub(query)
	} else {
		return fake.groupReturns.result1
	}
}

func (fake *FakeGormDB) GroupCallCount() int {
	fake.groupMutex.RLock()
	defer fake.groupMutex.RUnlock()
	return len(fake.groupArgsForCall)
}

func (fake *FakeGormDB) GroupArgsForCall(i int) string {
	fake.groupMutex.RLock()
	defer fake.groupMutex.RUnlock()
	return fake.groupArgsForCall[i].query
}

func (fake *FakeGormDB) GroupReturns(result1 *gorm.DB) {
	fake.GroupStub = nil
	fake.groupReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) HasTable(value interface{}) bool {
	fake.hasTableMutex.Lock()
	fake.hasTableArgsForCall = append(fake.hasTableArgsForCall, struct {
		value interface{}
	}{value})
	fake.hasTableMutex.Unlock()
	if fake.HasTableStub != nil {
		return fake.HasTableStub(value)
	} else {
		return fake.hasTableReturns.result1
	}
}

func (fake *FakeGormDB) HasTableCallCount() int {
	fake.hasTableMutex.RLock()
	defer fake.hasTableMutex.RUnlock()
	return len(fake.hasTableArgsForCall)
}

func (fake *FakeGormDB) HasTableArgsForCall(i int) interface{} {
	fake.hasTableMutex.RLock()
	defer fake.hasTableMutex.RUnlock()
	return fake.hasTableArgsForCall[i].value
}

func (fake *FakeGormDB) HasTableReturns(result1 bool) {
	fake.HasTableStub = nil
	fake.hasTableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGormDB) Having(query string, values ...interface{}) *gorm.DB {
	fake.havingMutex.Lock()
	fake.havingArgsForCall = append(fake.havingArgsForCall, struct {
		query  string
		values []interface{}
	}{query, values})
	fake.havingMutex.Unlock()
	if fake.HavingStub != nil {
		return fake.HavingStub(query, values...)
	} else {
		return fake.havingReturns.result1
	}
}

func (fake *FakeGormDB) HavingCallCount() int {
	fake.havingMutex.RLock()
	defer fake.havingMutex.RUnlock()
	return len(fake.havingArgsForCall)
}

func (fake *FakeGormDB) HavingArgsForCall(i int) (string, []interface{}) {
	fake.havingMutex.RLock()
	defer fake.havingMutex.RUnlock()
	return fake.havingArgsForCall[i].query, fake.havingArgsForCall[i].values
}

func (fake *FakeGormDB) HavingReturns(result1 *gorm.DB) {
	fake.HavingStub = nil
	fake.havingReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) InstantSet(name string, value interface{}) *gorm.DB {
	fake.instantSetMutex.Lock()
	fake.instantSetArgsForCall = append(fake.instantSetArgsForCall, struct {
		name  string
		value interface{}
	}{name, value})
	fake.instantSetMutex.Unlock()
	if fake.InstantSetStub != nil {
		return fake.InstantSetStub(name, value)
	} else {
		return fake.instantSetReturns.result1
	}
}

func (fake *FakeGormDB) InstantSetCallCount() int {
	fake.instantSetMutex.RLock()
	defer fake.instantSetMutex.RUnlock()
	return len(fake.instantSetArgsForCall)
}

func (fake *FakeGormDB) InstantSetArgsForCall(i int) (string, interface{}) {
	fake.instantSetMutex.RLock()
	defer fake.instantSetMutex.RUnlock()
	return fake.instantSetArgsForCall[i].name, fake.instantSetArgsForCall[i].value
}

func (fake *FakeGormDB) InstantSetReturns(result1 *gorm.DB) {
	fake.InstantSetStub = nil
	fake.instantSetReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Joins(query string) *gorm.DB {
	fake.joinsMutex.Lock()
	fake.joinsArgsForCall = append(fake.joinsArgsForCall, struct {
		query string
	}{query})
	fake.joinsMutex.Unlock()
	if fake.JoinsStub != nil {
		return fake.JoinsStub(query)
	} else {
		return fake.joinsReturns.result1
	}
}

func (fake *FakeGormDB) JoinsCallCount() int {
	fake.joinsMutex.RLock()
	defer fake.joinsMutex.RUnlock()
	return len(fake.joinsArgsForCall)
}

func (fake *FakeGormDB) JoinsArgsForCall(i int) string {
	fake.joinsMutex.RLock()
	defer fake.joinsMutex.RUnlock()
	return fake.joinsArgsForCall[i].query
}

func (fake *FakeGormDB) JoinsReturns(result1 *gorm.DB) {
	fake.JoinsStub = nil
	fake.joinsReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Last(out interface{}, where ...interface{}) *gorm.DB {
	fake.lastMutex.Lock()
	fake.lastArgsForCall = append(fake.lastArgsForCall, struct {
		out   interface{}
		where []interface{}
	}{out, where})
	fake.lastMutex.Unlock()
	if fake.LastStub != nil {
		return fake.LastStub(out, where...)
	} else {
		return fake.lastReturns.result1
	}
}

func (fake *FakeGormDB) LastCallCount() int {
	fake.lastMutex.RLock()
	defer fake.lastMutex.RUnlock()
	return len(fake.lastArgsForCall)
}

func (fake *FakeGormDB) LastArgsForCall(i int) (interface{}, []interface{}) {
	fake.lastMutex.RLock()
	defer fake.lastMutex.RUnlock()
	return fake.lastArgsForCall[i].out, fake.lastArgsForCall[i].where
}

func (fake *FakeGormDB) LastReturns(result1 *gorm.DB) {
	fake.LastStub = nil
	fake.lastReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Limit(value interface{}) *gorm.DB {
	fake.limitMutex.Lock()
	fake.limitArgsForCall = append(fake.limitArgsForCall, struct {
		value interface{}
	}{value})
	fake.limitMutex.Unlock()
	if fake.LimitStub != nil {
		return fake.LimitStub(value)
	} else {
		return fake.limitReturns.result1
	}
}

func (fake *FakeGormDB) LimitCallCount() int {
	fake.limitMutex.RLock()
	defer fake.limitMutex.RUnlock()
	return len(fake.limitArgsForCall)
}

func (fake *FakeGormDB) LimitArgsForCall(i int) interface{} {
	fake.limitMutex.RLock()
	defer fake.limitMutex.RUnlock()
	return fake.limitArgsForCall[i].value
}

func (fake *FakeGormDB) LimitReturns(result1 *gorm.DB) {
	fake.LimitStub = nil
	fake.limitReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) LogMode(enable bool) *gorm.DB {
	fake.logModeMutex.Lock()
	fake.logModeArgsForCall = append(fake.logModeArgsForCall, struct {
		enable bool
	}{enable})
	fake.logModeMutex.Unlock()
	if fake.LogModeStub != nil {
		return fake.LogModeStub(enable)
	} else {
		return fake.logModeReturns.result1
	}
}

func (fake *FakeGormDB) LogModeCallCount() int {
	fake.logModeMutex.RLock()
	defer fake.logModeMutex.RUnlock()
	return len(fake.logModeArgsForCall)
}

func (fake *FakeGormDB) LogModeArgsForCall(i int) bool {
	fake.logModeMutex.RLock()
	defer fake.logModeMutex.RUnlock()
	return fake.logModeArgsForCall[i].enable
}

func (fake *FakeGormDB) LogModeReturns(result1 *gorm.DB) {
	fake.LogModeStub = nil
	fake.logModeReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Model(value interface{}) *gorm.DB {
	fake.modelMutex.Lock()
	fake.modelArgsForCall = append(fake.modelArgsForCall, struct {
		value interface{}
	}{value})
	fake.modelMutex.Unlock()
	if fake.ModelStub != nil {
		return fake.ModelStub(value)
	} else {
		return fake.modelReturns.result1
	}
}

func (fake *FakeGormDB) ModelCallCount() int {
	fake.modelMutex.RLock()
	defer fake.modelMutex.RUnlock()
	return len(fake.modelArgsForCall)
}

func (fake *FakeGormDB) ModelArgsForCall(i int) interface{} {
	fake.modelMutex.RLock()
	defer fake.modelMutex.RUnlock()
	return fake.modelArgsForCall[i].value
}

func (fake *FakeGormDB) ModelReturns(result1 *gorm.DB) {
	fake.ModelStub = nil
	fake.modelReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) ModifyColumn(column string, typ string) *gorm.DB {
	fake.modifyColumnMutex.Lock()
	fake.modifyColumnArgsForCall = append(fake.modifyColumnArgsForCall, struct {
		column string
		typ    string
	}{column, typ})
	fake.modifyColumnMutex.Unlock()
	if fake.ModifyColumnStub != nil {
		return fake.ModifyColumnStub(column, typ)
	} else {
		return fake.modifyColumnReturns.result1
	}
}

func (fake *FakeGormDB) ModifyColumnCallCount() int {
	fake.modifyColumnMutex.RLock()
	defer fake.modifyColumnMutex.RUnlock()
	return len(fake.modifyColumnArgsForCall)
}

func (fake *FakeGormDB) ModifyColumnArgsForCall(i int) (string, string) {
	fake.modifyColumnMutex.RLock()
	defer fake.modifyColumnMutex.RUnlock()
	return fake.modifyColumnArgsForCall[i].column, fake.modifyColumnArgsForCall[i].typ
}

func (fake *FakeGormDB) ModifyColumnReturns(result1 *gorm.DB) {
	fake.ModifyColumnStub = nil
	fake.modifyColumnReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) New() *gorm.DB {
	fake.newMutex.Lock()
	fake.newArgsForCall = append(fake.newArgsForCall, struct{}{})
	fake.newMutex.Unlock()
	if fake.NewStub != nil {
		return fake.NewStub()
	} else {
		return fake.newReturns.result1
	}
}

func (fake *FakeGormDB) NewCallCount() int {
	fake.newMutex.RLock()
	defer fake.newMutex.RUnlock()
	return len(fake.newArgsForCall)
}

func (fake *FakeGormDB) NewReturns(result1 *gorm.DB) {
	fake.NewStub = nil
	fake.newReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) NewRecord(value interface{}) bool {
	fake.newRecordMutex.Lock()
	fake.newRecordArgsForCall = append(fake.newRecordArgsForCall, struct {
		value interface{}
	}{value})
	fake.newRecordMutex.Unlock()
	if fake.NewRecordStub != nil {
		return fake.NewRecordStub(value)
	} else {
		return fake.newRecordReturns.result1
	}
}

func (fake *FakeGormDB) NewRecordCallCount() int {
	fake.newRecordMutex.RLock()
	defer fake.newRecordMutex.RUnlock()
	return len(fake.newRecordArgsForCall)
}

func (fake *FakeGormDB) NewRecordArgsForCall(i int) interface{} {
	fake.newRecordMutex.RLock()
	defer fake.newRecordMutex.RUnlock()
	return fake.newRecordArgsForCall[i].value
}

func (fake *FakeGormDB) NewRecordReturns(result1 bool) {
	fake.NewRecordStub = nil
	fake.newRecordReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGormDB) NewScope(value interface{}) *gorm.Scope {
	fake.newScopeMutex.Lock()
	fake.newScopeArgsForCall = append(fake.newScopeArgsForCall, struct {
		value interface{}
	}{value})
	fake.newScopeMutex.Unlock()
	if fake.NewScopeStub != nil {
		return fake.NewScopeStub(value)
	} else {
		return fake.newScopeReturns.result1
	}
}

func (fake *FakeGormDB) NewScopeCallCount() int {
	fake.newScopeMutex.RLock()
	defer fake.newScopeMutex.RUnlock()
	return len(fake.newScopeArgsForCall)
}

func (fake *FakeGormDB) NewScopeArgsForCall(i int) interface{} {
	fake.newScopeMutex.RLock()
	defer fake.newScopeMutex.RUnlock()
	return fake.newScopeArgsForCall[i].value
}

func (fake *FakeGormDB) NewScopeReturns(result1 *gorm.Scope) {
	fake.NewScopeStub = nil
	fake.newScopeReturns = struct {
		result1 *gorm.Scope
	}{result1}
}

func (fake *FakeGormDB) Not(query interface{}, args ...interface{}) *gorm.DB {
	fake.notMutex.Lock()
	fake.notArgsForCall = append(fake.notArgsForCall, struct {
		query interface{}
		args  []interface{}
	}{query, args})
	fake.notMutex.Unlock()
	if fake.NotStub != nil {
		return fake.NotStub(query, args...)
	} else {
		return fake.notReturns.result1
	}
}

func (fake *FakeGormDB) NotCallCount() int {
	fake.notMutex.RLock()
	defer fake.notMutex.RUnlock()
	return len(fake.notArgsForCall)
}

func (fake *FakeGormDB) NotArgsForCall(i int) (interface{}, []interface{}) {
	fake.notMutex.RLock()
	defer fake.notMutex.RUnlock()
	return fake.notArgsForCall[i].query, fake.notArgsForCall[i].args
}

func (fake *FakeGormDB) NotReturns(result1 *gorm.DB) {
	fake.NotStub = nil
	fake.notReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Offset(value interface{}) *gorm.DB {
	fake.offsetMutex.Lock()
	fake.offsetArgsForCall = append(fake.offsetArgsForCall, struct {
		value interface{}
	}{value})
	fake.offsetMutex.Unlock()
	if fake.OffsetStub != nil {
		return fake.OffsetStub(value)
	} else {
		return fake.offsetReturns.result1
	}
}

func (fake *FakeGormDB) OffsetCallCount() int {
	fake.offsetMutex.RLock()
	defer fake.offsetMutex.RUnlock()
	return len(fake.offsetArgsForCall)
}

func (fake *FakeGormDB) OffsetArgsForCall(i int) interface{} {
	fake.offsetMutex.RLock()
	defer fake.offsetMutex.RUnlock()
	return fake.offsetArgsForCall[i].value
}

func (fake *FakeGormDB) OffsetReturns(result1 *gorm.DB) {
	fake.OffsetStub = nil
	fake.offsetReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Omit(columns ...string) *gorm.DB {
	fake.omitMutex.Lock()
	fake.omitArgsForCall = append(fake.omitArgsForCall, struct {
		columns []string
	}{columns})
	fake.omitMutex.Unlock()
	if fake.OmitStub != nil {
		return fake.OmitStub(columns...)
	} else {
		return fake.omitReturns.result1
	}
}

func (fake *FakeGormDB) OmitCallCount() int {
	fake.omitMutex.RLock()
	defer fake.omitMutex.RUnlock()
	return len(fake.omitArgsForCall)
}

func (fake *FakeGormDB) OmitArgsForCall(i int) []string {
	fake.omitMutex.RLock()
	defer fake.omitMutex.RUnlock()
	return fake.omitArgsForCall[i].columns
}

func (fake *FakeGormDB) OmitReturns(result1 *gorm.DB) {
	fake.OmitStub = nil
	fake.omitReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Or(query interface{}, args ...interface{}) *gorm.DB {
	fake.orMutex.Lock()
	fake.orArgsForCall = append(fake.orArgsForCall, struct {
		query interface{}
		args  []interface{}
	}{query, args})
	fake.orMutex.Unlock()
	if fake.OrStub != nil {
		return fake.OrStub(query, args...)
	} else {
		return fake.orReturns.result1
	}
}

func (fake *FakeGormDB) OrCallCount() int {
	fake.orMutex.RLock()
	defer fake.orMutex.RUnlock()
	return len(fake.orArgsForCall)
}

func (fake *FakeGormDB) OrArgsForCall(i int) (interface{}, []interface{}) {
	fake.orMutex.RLock()
	defer fake.orMutex.RUnlock()
	return fake.orArgsForCall[i].query, fake.orArgsForCall[i].args
}

func (fake *FakeGormDB) OrReturns(result1 *gorm.DB) {
	fake.OrStub = nil
	fake.orReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Order(value string, reorder ...bool) *gorm.DB {
	fake.orderMutex.Lock()
	fake.orderArgsForCall = append(fake.orderArgsForCall, struct {
		value   string
		reorder []bool
	}{value, reorder})
	fake.orderMutex.Unlock()
	if fake.OrderStub != nil {
		return fake.OrderStub(value, reorder...)
	} else {
		return fake.orderReturns.result1
	}
}

func (fake *FakeGormDB) OrderCallCount() int {
	fake.orderMutex.RLock()
	defer fake.orderMutex.RUnlock()
	return len(fake.orderArgsForCall)
}

func (fake *FakeGormDB) OrderArgsForCall(i int) (string, []bool) {
	fake.orderMutex.RLock()
	defer fake.orderMutex.RUnlock()
	return fake.orderArgsForCall[i].value, fake.orderArgsForCall[i].reorder
}

func (fake *FakeGormDB) OrderReturns(result1 *gorm.DB) {
	fake.OrderStub = nil
	fake.orderReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Pluck(column string, value interface{}) *gorm.DB {
	fake.pluckMutex.Lock()
	fake.pluckArgsForCall = append(fake.pluckArgsForCall, struct {
		column string
		value  interface{}
	}{column, value})
	fake.pluckMutex.Unlock()
	if fake.PluckStub != nil {
		return fake.PluckStub(column, value)
	} else {
		return fake.pluckReturns.result1
	}
}

func (fake *FakeGormDB) PluckCallCount() int {
	fake.pluckMutex.RLock()
	defer fake.pluckMutex.RUnlock()
	return len(fake.pluckArgsForCall)
}

func (fake *FakeGormDB) PluckArgsForCall(i int) (string, interface{}) {
	fake.pluckMutex.RLock()
	defer fake.pluckMutex.RUnlock()
	return fake.pluckArgsForCall[i].column, fake.pluckArgsForCall[i].value
}

func (fake *FakeGormDB) PluckReturns(result1 *gorm.DB) {
	fake.PluckStub = nil
	fake.pluckReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Preload(column string, conditions ...interface{}) *gorm.DB {
	fake.preloadMutex.Lock()
	fake.preloadArgsForCall = append(fake.preloadArgsForCall, struct {
		column     string
		conditions []interface{}
	}{column, conditions})
	fake.preloadMutex.Unlock()
	if fake.PreloadStub != nil {
		return fake.PreloadStub(column, conditions...)
	} else {
		return fake.preloadReturns.result1
	}
}

func (fake *FakeGormDB) PreloadCallCount() int {
	fake.preloadMutex.RLock()
	defer fake.preloadMutex.RUnlock()
	return len(fake.preloadArgsForCall)
}

func (fake *FakeGormDB) PreloadArgsForCall(i int) (string, []interface{}) {
	fake.preloadMutex.RLock()
	defer fake.preloadMutex.RUnlock()
	return fake.preloadArgsForCall[i].column, fake.preloadArgsForCall[i].conditions
}

func (fake *FakeGormDB) PreloadReturns(result1 *gorm.DB) {
	fake.PreloadStub = nil
	fake.preloadReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Raw(sql string, values ...interface{}) *gorm.DB {
	fake.rawMutex.Lock()
	fake.rawArgsForCall = append(fake.rawArgsForCall, struct {
		sql    string
		values []interface{}
	}{sql, values})
	fake.rawMutex.Unlock()
	if fake.RawStub != nil {
		return fake.RawStub(sql, values...)
	} else {
		return fake.rawReturns.result1
	}
}

func (fake *FakeGormDB) RawCallCount() int {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return len(fake.rawArgsForCall)
}

func (fake *FakeGormDB) RawArgsForCall(i int) (string, []interface{}) {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return fake.rawArgsForCall[i].sql, fake.rawArgsForCall[i].values
}

func (fake *FakeGormDB) RawReturns(result1 *gorm.DB) {
	fake.RawStub = nil
	fake.rawReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) RecordNotFound() bool {
	fake.recordNotFoundMutex.Lock()
	fake.recordNotFoundArgsForCall = append(fake.recordNotFoundArgsForCall, struct{}{})
	fake.recordNotFoundMutex.Unlock()
	if fake.RecordNotFoundStub != nil {
		return fake.RecordNotFoundStub()
	} else {
		return fake.recordNotFoundReturns.result1
	}
}

func (fake *FakeGormDB) RecordNotFoundCallCount() int {
	fake.recordNotFoundMutex.RLock()
	defer fake.recordNotFoundMutex.RUnlock()
	return len(fake.recordNotFoundArgsForCall)
}

func (fake *FakeGormDB) RecordNotFoundReturns(result1 bool) {
	fake.RecordNotFoundStub = nil
	fake.recordNotFoundReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGormDB) Related(value interface{}, foreignKeys ...string) *gorm.DB {
	fake.relatedMutex.Lock()
	fake.relatedArgsForCall = append(fake.relatedArgsForCall, struct {
		value       interface{}
		foreignKeys []string
	}{value, foreignKeys})
	fake.relatedMutex.Unlock()
	if fake.RelatedStub != nil {
		return fake.RelatedStub(value, foreignKeys...)
	} else {
		return fake.relatedReturns.result1
	}
}

func (fake *FakeGormDB) RelatedCallCount() int {
	fake.relatedMutex.RLock()
	defer fake.relatedMutex.RUnlock()
	return len(fake.relatedArgsForCall)
}

func (fake *FakeGormDB) RelatedArgsForCall(i int) (interface{}, []string) {
	fake.relatedMutex.RLock()
	defer fake.relatedMutex.RUnlock()
	return fake.relatedArgsForCall[i].value, fake.relatedArgsForCall[i].foreignKeys
}

func (fake *FakeGormDB) RelatedReturns(result1 *gorm.DB) {
	fake.RelatedStub = nil
	fake.relatedReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) RemoveIndex(indexName string) *gorm.DB {
	fake.removeIndexMutex.Lock()
	fake.removeIndexArgsForCall = append(fake.removeIndexArgsForCall, struct {
		indexName string
	}{indexName})
	fake.removeIndexMutex.Unlock()
	if fake.RemoveIndexStub != nil {
		return fake.RemoveIndexStub(indexName)
	} else {
		return fake.removeIndexReturns.result1
	}
}

func (fake *FakeGormDB) RemoveIndexCallCount() int {
	fake.removeIndexMutex.RLock()
	defer fake.removeIndexMutex.RUnlock()
	return len(fake.removeIndexArgsForCall)
}

func (fake *FakeGormDB) RemoveIndexArgsForCall(i int) string {
	fake.removeIndexMutex.RLock()
	defer fake.removeIndexMutex.RUnlock()
	return fake.removeIndexArgsForCall[i].indexName
}

func (fake *FakeGormDB) RemoveIndexReturns(result1 *gorm.DB) {
	fake.RemoveIndexStub = nil
	fake.removeIndexReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Rollback() *gorm.DB {
	fake.rollbackMutex.Lock()
	fake.rollbackArgsForCall = append(fake.rollbackArgsForCall, struct{}{})
	fake.rollbackMutex.Unlock()
	if fake.RollbackStub != nil {
		return fake.RollbackStub()
	} else {
		return fake.rollbackReturns.result1
	}
}

func (fake *FakeGormDB) RollbackCallCount() int {
	fake.rollbackMutex.RLock()
	defer fake.rollbackMutex.RUnlock()
	return len(fake.rollbackArgsForCall)
}

func (fake *FakeGormDB) RollbackReturns(result1 *gorm.DB) {
	fake.RollbackStub = nil
	fake.rollbackReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Row() *sql.Row {
	fake.rowMutex.Lock()
	fake.rowArgsForCall = append(fake.rowArgsForCall, struct{}{})
	fake.rowMutex.Unlock()
	if fake.RowStub != nil {
		return fake.RowStub()
	} else {
		return fake.rowReturns.result1
	}
}

func (fake *FakeGormDB) RowCallCount() int {
	fake.rowMutex.RLock()
	defer fake.rowMutex.RUnlock()
	return len(fake.rowArgsForCall)
}

func (fake *FakeGormDB) RowReturns(result1 *sql.Row) {
	fake.RowStub = nil
	fake.rowReturns = struct {
		result1 *sql.Row
	}{result1}
}

func (fake *FakeGormDB) Rows() (*sql.Rows, error) {
	fake.rowsMutex.Lock()
	fake.rowsArgsForCall = append(fake.rowsArgsForCall, struct{}{})
	fake.rowsMutex.Unlock()
	if fake.RowsStub != nil {
		return fake.RowsStub()
	} else {
		return fake.rowsReturns.result1, fake.rowsReturns.result2
	}
}

func (fake *FakeGormDB) RowsCallCount() int {
	fake.rowsMutex.RLock()
	defer fake.rowsMutex.RUnlock()
	return len(fake.rowsArgsForCall)
}

func (fake *FakeGormDB) RowsReturns(result1 *sql.Rows, result2 error) {
	fake.RowsStub = nil
	fake.rowsReturns = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *FakeGormDB) Save(value interface{}) *gorm.DB {
	fake.saveMutex.Lock()
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
		value interface{}
	}{value})
	fake.saveMutex.Unlock()
	if fake.SaveStub != nil {
		return fake.SaveStub(value)
	} else {
		return fake.saveReturns.result1
	}
}

func (fake *FakeGormDB) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *FakeGormDB) SaveArgsForCall(i int) interface{} {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return fake.saveArgsForCall[i].value
}

func (fake *FakeGormDB) SaveReturns(result1 *gorm.DB) {
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Scan(dest interface{}) *gorm.DB {
	fake.scanMutex.Lock()
	fake.scanArgsForCall = append(fake.scanArgsForCall, struct {
		dest interface{}
	}{dest})
	fake.scanMutex.Unlock()
	if fake.ScanStub != nil {
		return fake.ScanStub(dest)
	} else {
		return fake.scanReturns.result1
	}
}

func (fake *FakeGormDB) ScanCallCount() int {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return len(fake.scanArgsForCall)
}

func (fake *FakeGormDB) ScanArgsForCall(i int) interface{} {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return fake.scanArgsForCall[i].dest
}

func (fake *FakeGormDB) ScanReturns(result1 *gorm.DB) {
	fake.ScanStub = nil
	fake.scanReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Scopes(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB {
	fake.scopesMutex.Lock()
	fake.scopesArgsForCall = append(fake.scopesArgsForCall, struct {
		funcs []func(*gorm.DB) *gorm.DB
	}{funcs})
	fake.scopesMutex.Unlock()
	if fake.ScopesStub != nil {
		return fake.ScopesStub(funcs...)
	} else {
		return fake.scopesReturns.result1
	}
}

func (fake *FakeGormDB) ScopesCallCount() int {
	fake.scopesMutex.RLock()
	defer fake.scopesMutex.RUnlock()
	return len(fake.scopesArgsForCall)
}

func (fake *FakeGormDB) ScopesArgsForCall(i int) []func(*gorm.DB) *gorm.DB {
	fake.scopesMutex.RLock()
	defer fake.scopesMutex.RUnlock()
	return fake.scopesArgsForCall[i].funcs
}

func (fake *FakeGormDB) ScopesReturns(result1 *gorm.DB) {
	fake.ScopesStub = nil
	fake.scopesReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Select(query interface{}, args ...interface{}) *gorm.DB {
	fake.selectMutex.Lock()
	fake.selectArgsForCall = append(fake.selectArgsForCall, struct {
		query interface{}
		args  []interface{}
	}{query, args})
	fake.selectMutex.Unlock()
	if fake.SelectStub != nil {
		return fake.SelectStub(query, args...)
	} else {
		return fake.selectReturns.result1
	}
}

func (fake *FakeGormDB) SelectCallCount() int {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return len(fake.selectArgsForCall)
}

func (fake *FakeGormDB) SelectArgsForCall(i int) (interface{}, []interface{}) {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return fake.selectArgsForCall[i].query, fake.selectArgsForCall[i].args
}

func (fake *FakeGormDB) SelectReturns(result1 *gorm.DB) {
	fake.SelectStub = nil
	fake.selectReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Set(name string, value interface{}) *gorm.DB {
	fake.setMutex.Lock()
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		name  string
		value interface{}
	}{name, value})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(name, value)
	} else {
		return fake.setReturns.result1
	}
}

func (fake *FakeGormDB) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeGormDB) SetArgsForCall(i int) (string, interface{}) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].name, fake.setArgsForCall[i].value
}

func (fake *FakeGormDB) SetReturns(result1 *gorm.DB) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) SetJoinTableHandler(source interface{}, column string, handler gorm.JoinTableHandlerInterface) {
	fake.setJoinTableHandlerMutex.Lock()
	fake.setJoinTableHandlerArgsForCall = append(fake.setJoinTableHandlerArgsForCall, struct {
		source  interface{}
		column  string
		handler gorm.JoinTableHandlerInterface
	}{source, column, handler})
	fake.setJoinTableHandlerMutex.Unlock()
	if fake.SetJoinTableHandlerStub != nil {
		fake.SetJoinTableHandlerStub(source, column, handler)
	}
}

func (fake *FakeGormDB) SetJoinTableHandlerCallCount() int {
	fake.setJoinTableHandlerMutex.RLock()
	defer fake.setJoinTableHandlerMutex.RUnlock()
	return len(fake.setJoinTableHandlerArgsForCall)
}

func (fake *FakeGormDB) SetJoinTableHandlerArgsForCall(i int) (interface{}, string, gorm.JoinTableHandlerInterface) {
	fake.setJoinTableHandlerMutex.RLock()
	defer fake.setJoinTableHandlerMutex.RUnlock()
	return fake.setJoinTableHandlerArgsForCall[i].source, fake.setJoinTableHandlerArgsForCall[i].column, fake.setJoinTableHandlerArgsForCall[i].handler
}

func (fake *FakeGormDB) SingularTable(enable bool) {
	fake.singularTableMutex.Lock()
	fake.singularTableArgsForCall = append(fake.singularTableArgsForCall, struct {
		enable bool
	}{enable})
	fake.singularTableMutex.Unlock()
	if fake.SingularTableStub != nil {
		fake.SingularTableStub(enable)
	}
}

func (fake *FakeGormDB) SingularTableCallCount() int {
	fake.singularTableMutex.RLock()
	defer fake.singularTableMutex.RUnlock()
	return len(fake.singularTableArgsForCall)
}

func (fake *FakeGormDB) SingularTableArgsForCall(i int) bool {
	fake.singularTableMutex.RLock()
	defer fake.singularTableMutex.RUnlock()
	return fake.singularTableArgsForCall[i].enable
}

func (fake *FakeGormDB) Table(name string) *gorm.DB {
	fake.tableMutex.Lock()
	fake.tableArgsForCall = append(fake.tableArgsForCall, struct {
		name string
	}{name})
	fake.tableMutex.Unlock()
	if fake.TableStub != nil {
		return fake.TableStub(name)
	} else {
		return fake.tableReturns.result1
	}
}

func (fake *FakeGormDB) TableCallCount() int {
	fake.tableMutex.RLock()
	defer fake.tableMutex.RUnlock()
	return len(fake.tableArgsForCall)
}

func (fake *FakeGormDB) TableArgsForCall(i int) string {
	fake.tableMutex.RLock()
	defer fake.tableMutex.RUnlock()
	return fake.tableArgsForCall[i].name
}

func (fake *FakeGormDB) TableReturns(result1 *gorm.DB) {
	fake.TableStub = nil
	fake.tableReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Unscoped() *gorm.DB {
	fake.unscopedMutex.Lock()
	fake.unscopedArgsForCall = append(fake.unscopedArgsForCall, struct{}{})
	fake.unscopedMutex.Unlock()
	if fake.UnscopedStub != nil {
		return fake.UnscopedStub()
	} else {
		return fake.unscopedReturns.result1
	}
}

func (fake *FakeGormDB) UnscopedCallCount() int {
	fake.unscopedMutex.RLock()
	defer fake.unscopedMutex.RUnlock()
	return len(fake.unscopedArgsForCall)
}

func (fake *FakeGormDB) UnscopedReturns(result1 *gorm.DB) {
	fake.UnscopedStub = nil
	fake.unscopedReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Update(attrs ...interface{}) *gorm.DB {
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		attrs []interface{}
	}{attrs})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(attrs...)
	} else {
		return fake.updateReturns.result1
	}
}

func (fake *FakeGormDB) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeGormDB) UpdateArgsForCall(i int) []interface{} {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].attrs
}

func (fake *FakeGormDB) UpdateReturns(result1 *gorm.DB) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) UpdateColumn(attrs ...interface{}) *gorm.DB {
	fake.updateColumnMutex.Lock()
	fake.updateColumnArgsForCall = append(fake.updateColumnArgsForCall, struct {
		attrs []interface{}
	}{attrs})
	fake.updateColumnMutex.Unlock()
	if fake.UpdateColumnStub != nil {
		return fake.UpdateColumnStub(attrs...)
	} else {
		return fake.updateColumnReturns.result1
	}
}

func (fake *FakeGormDB) UpdateColumnCallCount() int {
	fake.updateColumnMutex.RLock()
	defer fake.updateColumnMutex.RUnlock()
	return len(fake.updateColumnArgsForCall)
}

func (fake *FakeGormDB) UpdateColumnArgsForCall(i int) []interface{} {
	fake.updateColumnMutex.RLock()
	defer fake.updateColumnMutex.RUnlock()
	return fake.updateColumnArgsForCall[i].attrs
}

func (fake *FakeGormDB) UpdateColumnReturns(result1 *gorm.DB) {
	fake.UpdateColumnStub = nil
	fake.updateColumnReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) UpdateColumns(values interface{}) *gorm.DB {
	fake.updateColumnsMutex.Lock()
	fake.updateColumnsArgsForCall = append(fake.updateColumnsArgsForCall, struct {
		values interface{}
	}{values})
	fake.updateColumnsMutex.Unlock()
	if fake.UpdateColumnsStub != nil {
		return fake.UpdateColumnsStub(values)
	} else {
		return fake.updateColumnsReturns.result1
	}
}

func (fake *FakeGormDB) UpdateColumnsCallCount() int {
	fake.updateColumnsMutex.RLock()
	defer fake.updateColumnsMutex.RUnlock()
	return len(fake.updateColumnsArgsForCall)
}

func (fake *FakeGormDB) UpdateColumnsArgsForCall(i int) interface{} {
	fake.updateColumnsMutex.RLock()
	defer fake.updateColumnsMutex.RUnlock()
	return fake.updateColumnsArgsForCall[i].values
}

func (fake *FakeGormDB) UpdateColumnsReturns(result1 *gorm.DB) {
	fake.UpdateColumnsStub = nil
	fake.updateColumnsReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Updates(values interface{}, ignoreProtectedAttrs ...bool) *gorm.DB {
	fake.updatesMutex.Lock()
	fake.updatesArgsForCall = append(fake.updatesArgsForCall, struct {
		values               interface{}
		ignoreProtectedAttrs []bool
	}{values, ignoreProtectedAttrs})
	fake.updatesMutex.Unlock()
	if fake.UpdatesStub != nil {
		return fake.UpdatesStub(values, ignoreProtectedAttrs...)
	} else {
		return fake.updatesReturns.result1
	}
}

func (fake *FakeGormDB) UpdatesCallCount() int {
	fake.updatesMutex.RLock()
	defer fake.updatesMutex.RUnlock()
	return len(fake.updatesArgsForCall)
}

func (fake *FakeGormDB) UpdatesArgsForCall(i int) (interface{}, []bool) {
	fake.updatesMutex.RLock()
	defer fake.updatesMutex.RUnlock()
	return fake.updatesArgsForCall[i].values, fake.updatesArgsForCall[i].ignoreProtectedAttrs
}

func (fake *FakeGormDB) UpdatesReturns(result1 *gorm.DB) {
	fake.UpdatesStub = nil
	fake.updatesReturns = struct {
		result1 *gorm.DB
	}{result1}
}

func (fake *FakeGormDB) Where(query interface{}, args ...interface{}) chaospeddler.GormDB {
	fake.whereMutex.Lock()
	fake.whereArgsForCall = append(fake.whereArgsForCall, struct {
		query interface{}
		args  []interface{}
	}{query, args})
	fake.whereMutex.Unlock()
	if fake.WhereStub != nil {
		return fake.WhereStub(query, args...)
	} else {
		return fake.whereReturns.result1
	}
}

func (fake *FakeGormDB) WhereCallCount() int {
	fake.whereMutex.RLock()
	defer fake.whereMutex.RUnlock()
	return len(fake.whereArgsForCall)
}

func (fake *FakeGormDB) WhereArgsForCall(i int) (interface{}, []interface{}) {
	fake.whereMutex.RLock()
	defer fake.whereMutex.RUnlock()
	return fake.whereArgsForCall[i].query, fake.whereArgsForCall[i].args
}

func (fake *FakeGormDB) WhereReturns(result1 chaospeddler.GormDB) {
	fake.WhereStub = nil
	fake.whereReturns = struct {
		result1 chaospeddler.GormDB
	}{result1}
}

var _ chaospeddler.GormDB = new(FakeGormDB)
